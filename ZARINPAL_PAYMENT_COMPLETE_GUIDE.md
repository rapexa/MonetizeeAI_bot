# ğŸ“š Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒ Ú©Ø§Ù…Ù„ Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ù¾Ø±Ø¯Ø§Ø®Øª Ø¢Ù†Ù„Ø§ÛŒÙ† Ø¨Ø§ Ø²Ø±ÛŒÙ†â€ŒÙ¾Ø§Ù„

> **Ø§ÛŒÙ† Ø±Ø§Ù‡Ù†Ù…Ø§ Ø¨Ù‡ ØµÙˆØ±Øª Ú©Ø§Ù…Ù„ Ùˆ Ú¯Ø§Ù… Ø¨Ù‡ Ú¯Ø§Ù… Ù†Ø­ÙˆÙ‡ Ø§ØªØµØ§Ù„ ÙˆØ¨Ø³Ø§ÛŒØª  Ø¨Ù‡ Ø¯Ø±Ú¯Ø§Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª Ø²Ø±ÛŒÙ†â€ŒÙ¾Ø§Ù„ Ø±Ø§ Ø´Ø±Ø­ Ù…ÛŒâ€ŒØ¯Ù‡Ø¯**

---

## ğŸ“‹ ÙÙ‡Ø±Ø³Øª Ù…Ø·Ø§Ù„Ø¨

1. [Ù…Ø¹Ø±ÙÛŒ Ùˆ Ù…Ø¹Ù…Ø§Ø±ÛŒ](#1-Ù…Ø¹Ø±ÙÛŒ-Ùˆ-Ù…Ø¹Ù…Ø§Ø±ÛŒ)
2. [Ù¾ÛŒØ´â€ŒÙ†ÛŒØ§Ø²Ù‡Ø§](#2-Ù¾ÛŒØ´Ù†ÛŒØ§Ø²Ù‡Ø§)
3. [Ø³Ø§Ø®ØªØ§Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³](#3-Ø³Ø§Ø®ØªØ§Ø±-Ø¯ÛŒØªØ§Ø¨ÛŒØ³)
4. [Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ú¯Ø§Ù… Ø¨Ù‡ Ú¯Ø§Ù…](#4-Ù¾ÛŒØ§Ø¯Ù‡Ø³Ø§Ø²ÛŒ-Ú¯Ø§Ù…-Ø¨Ù‡-Ú¯Ø§Ù…)
5. [ØªÙ†Ø¸ÛŒÙ…Ø§Øª SSL Ùˆ HTTPS](#5-ØªÙ†Ø¸ÛŒÙ…Ø§Øª-ssl-Ùˆ-https)
6. [Ø¬Ø±ÛŒØ§Ù† Ú©Ø§Ù…Ù„ Ù¾Ø±Ø¯Ø§Ø®Øª](#6-Ø¬Ø±ÛŒØ§Ù†-Ú©Ø§Ù…Ù„-Ù¾Ø±Ø¯Ø§Ø®Øª)
7. [ØªØ³Øª Ùˆ Ø¯Ø¨ÛŒØ§Ú¯](#7-ØªØ³Øª-Ùˆ-Ø¯Ø¨ÛŒØ§Ú¯)
8. [Ù†Ú©Ø§Øª Ù…Ù‡Ù… Ùˆ Ø¨Ù‡ØªØ±ÛŒÙ† Ø±ÙˆØ´â€ŒÙ‡Ø§](#8-Ù†Ú©Ø§Øª-Ù…Ù‡Ù…-Ùˆ-Ø¨Ù‡ØªØ±ÛŒÙ†-Ø±ÙˆØ´Ù‡Ø§)

---

## 1. Ù…Ø¹Ø±ÙÛŒ Ùˆ Ù…Ø¹Ù…Ø§Ø±ÛŒ

### 1.1 Ú†Ø±Ø®Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª Ø²Ø±ÛŒÙ†â€ŒÙ¾Ø§Ù„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Ú©Ø§Ø±Ø¨Ø±     â”‚
â”‚  (ÙˆØ¨Ø³Ø§ÛŒØª) â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”‚ 1. Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ù¾Ø±Ø¯Ø§Ø®Øª
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ÙˆØ¨Ø³Ø§ÛŒØª    â”‚
â”‚  (Go Backend)   â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”‚ 2. Ø§ÛŒØ¬Ø§Ø¯ ØªØ±Ø§Ú©Ù†Ø´ Ø¯Ø± DB
       â”‚ 3. Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø¨Ù‡ ZarinPal API
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ZarinPal API   â”‚
â”‚  (Payment Gate) â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”‚ 4. Ø¨Ø§Ø²Ú¯Ø´Øª Authority
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Ú©Ø§Ø±Ø¨Ø± Ø¯Ø±       â”‚
â”‚  ØµÙØ­Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª   â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”‚ 5. Ù¾Ø±Ø¯Ø§Ø®Øª Ù…ÙˆÙÙ‚
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ZarinPal       â”‚
â”‚  Callback URL   â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚
       â”‚ 6. Verify Payment
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ÙˆØ¨Ø³Ø§ÛŒØª    â”‚
â”‚  (Update User)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 Ø§Ø¬Ø²Ø§ÛŒ Ø§ØµÙ„ÛŒ Ø³ÛŒØ³ØªÙ…

- **PaymentService**: Ø³Ø±ÙˆÛŒØ³ Ø§ØµÙ„ÛŒ Ø¨Ø±Ø§ÛŒ Ø§Ø±ØªØ¨Ø§Ø· Ø¨Ø§ ZarinPal
- **PaymentCallbackHandler**: Ù…Ø¯ÛŒØ±ÛŒØª callback Ø§Ø² Ø²Ø±ÛŒÙ†â€ŒÙ¾Ø§Ù„
- **PaymentTransaction**: Ù…Ø¯Ù„ Ø¯ÛŒØªØ§Ø¨ÛŒØ³ Ø¨Ø±Ø§ÛŒ Ø°Ø®ÛŒØ±Ù‡ ØªØ±Ø§Ú©Ù†Ø´â€ŒÙ‡Ø§
- **HTTP/HTTPS Server**: Ø³Ø±ÙˆØ± Ø¨Ø±Ø§ÛŒ Ø¯Ø±ÛŒØ§ÙØª callback

---

## 2. Ù¾ÛŒØ´â€ŒÙ†ÛŒØ§Ø²Ù‡Ø§

### 2.1 Ù…ÙˆØ§Ø±Ø¯ Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø²

- âœ… Go 1.21+
- âœ… MySQL 5.7+
- âœ… Ø­Ø³Ø§Ø¨ Ú©Ø§Ø±Ø¨Ø±ÛŒ ÙØ¹Ø§Ù„ Ø¯Ø± ZarinPal
- âœ… Merchant ID Ø§Ø² Ù¾Ù†Ù„ ZarinPal
- âœ… Ø¯Ø§Ù…Ù†Ù‡ Ø¨Ø§ SSL Ù…Ø¹ØªØ¨Ø± (Ø¨Ø±Ø§ÛŒ callback)
- âœ… Ù¾ÙˆØ±Øª 443 Ø¨Ø§Ø² Ø¯Ø± ÙØ§ÛŒØ±ÙˆØ§Ù„

### 2.2 Ø«Ø¨Øªâ€ŒÙ†Ø§Ù… Ø¯Ø± ZarinPal

1. Ø«Ø¨Øªâ€ŒÙ†Ø§Ù… Ø¯Ø± Ø³Ø§ÛŒØª [zarinpal.com](https://zarinpal.com)
2. ÙˆØ±ÙˆØ¯ Ø¨Ù‡ Ù¾Ù†Ù„ Ú©Ø§Ø±Ø¨Ø±ÛŒ
3. Ø¯Ø±ÛŒØ§ÙØª `Merchant ID`
4. ØªÙ†Ø¸ÛŒÙ… `Callback URL` Ø¯Ø± Ù¾Ù†Ù„

---

## 3. Ø³Ø§Ø®ØªØ§Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³

### 3.1 Ù…Ø¯Ù„ PaymentTransaction

```go
// models/gamification.go
package models

import (
    "time"
    "gorm.io/gorm"
)

// PaymentTransaction represents a payment transaction
type PaymentTransaction struct {
    ID          uint           `gorm:"primaryKey" json:"id"`
    UserID      uint           `gorm:"not null" json:"user_id"`
    User        User           `gorm:"foreignKey:UserID" json:"user"`
    Type        string         `gorm:"size:50;not null" json:"type"` 
    // Types: "subscription", "roadmap"
    Amount      int            `gorm:"not null" json:"amount"` // ØªÙˆÙ…Ø§Ù†
    Authority   string         `gorm:"size:100;uniqueIndex" json:"authority"`
    RefID       string         `gorm:"size:100" json:"ref_id"`
    Status      string         `gorm:"size:20;default:'pending'" json:"status"`
    // Statuses: "pending", "success", "failed"
    Description string         `gorm:"size:500" json:"description"`
    CreatedAt   time.Time      `json:"created_at"`
    UpdatedAt   time.Time      `json:"updated_at"`
    DeletedAt   gorm.DeletedAt `gorm:"index" json:"deleted_at,omitempty"`
}

func (PaymentTransaction) TableName() string {
    return "payment_transactions"
}
```

### 3.2 ÙÛŒÙ„Ø¯Ù‡Ø§ÛŒ User Ø¨Ø±Ø§ÛŒ Ù¾Ø±Ø¯Ø§Ø®Øª

```go
// models/user.go
type User struct {
    // ... Ø³Ø§ÛŒØ± ÙÛŒÙ„Ø¯Ù‡Ø§ ...
    SubscriptionEnd *time.Time `json:"subscription_end"` // ØªØ§Ø±ÛŒØ® Ø§Ù†Ù‚Ø¶Ø§ÛŒ Ø§Ø´ØªØ±Ø§Ú©
    HasPaidRoadmap  bool       `gorm:"default:false" json:"has_paid_roadmap"`
}
```

### 3.3 Migration

```go
// database/database.go
func InitDB(cfg *config.Config) error {
    // ...
    if err := DB.AutoMigrate(
        &models.User{},
        &models.PaymentTransaction{},
        // ...
    ); err != nil {
        return fmt.Errorf("failed to migrate database: %w", err)
    }
    return nil
}
```

---

## 4. Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ú¯Ø§Ù… Ø¨Ù‡ Ú¯Ø§Ù…

### 4.1 Ù…Ø±Ø­Ù„Ù‡ 1: ØªÙ†Ø¸ÛŒÙ…Ø§Øª Configuration

**ÙØ§ÛŒÙ„:** `config/config.go`

```go
package config

type PaymentConfig struct {
    MerchantID        string `mapstructure:"merchant_id"`        // Merchant ID Ø§Ø² ZarinPal
    Sandbox           bool   `mapstructure:"sandbox"`             // true = ØªØ³ØªÛŒØŒ false = ÙˆØ§Ù‚Ø¹ÛŒ
    CallbackURL       string `mapstructure:"callback_url"`       // URL callback
    SubscriptionPrice int    `mapstructure:"subscription_price"` // Ù‚ÛŒÙ…Øª Ø§Ø´ØªØ±Ø§Ú© (ØªÙˆÙ…Ø§Ù†)
    RoadmapPrice      int    `mapstructure:"roadmap_price"`      // Ù‚ÛŒÙ…Øª Ø±ÙˆØ¯Ù…Ù¾ (ØªÙˆÙ…Ø§Ù†)
}
```

**ÙØ§ÛŒÙ„:** `config.yaml`

```yaml
payment:
  merchant_id: "fcbfe898-c7bf-4bee-9ac4-e37e79f730f5"  # Merchant ID Ø´Ù…Ø§
  sandbox: false  # false Ø¨Ø±Ø§ÛŒ Ù…Ø­ÛŒØ· ÙˆØ§Ù‚Ø¹ÛŒ
  callback_url: "https://www.yourdomain.com/payment/callback"
  subscription_price: 5000   # 500,000 ØªÙˆÙ…Ø§Ù† = 5000 (Ø¨Ù‡ ØªÙˆÙ…Ø§Ù†)
  roadmap_price: 5000        # 50,000 ØªÙˆÙ…Ø§Ù† = 5000
```

### 4.2 Ù…Ø±Ø­Ù„Ù‡ 2: Ø³Ø§Ø®Øª PaymentService

**ÙØ§ÛŒÙ„:** `services/payment.go`

```go
package services

import (
    "avangard_ai_bot/config"
    "avangard_ai_bot/models"
    "bytes"
    "encoding/json"
    "fmt"
    "io"
    "log"
    "net/http"
    "time"
    "gorm.io/gorm"
)

// PaymentService handles payment operations with ZarinPal
type PaymentService struct {
    db     *gorm.DB
    config *config.PaymentConfig
}

// PaymentRequest - Ø³Ø§Ø®ØªØ§Ø± Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø¨Ù‡ ZarinPal
type PaymentRequest struct {
    MerchantID  string `json:"merchant_id"`
    Amount      int    `json:"amount"`
    Currency    string `json:"currency,omitempty"`    // "IRT" Ø¨Ø±Ø§ÛŒ ØªÙˆÙ…Ø§Ù†
    Description string `json:"description"`
    CallbackURL string `json:"callback_url"`
    Metadata    struct {
        Mobile  string `json:"mobile,omitempty"`
        Email   string `json:"email,omitempty"`
        OrderID string `json:"order_id,omitempty"`
    } `json:"metadata,omitempty"`
}

// PaymentResponse - Ù¾Ø§Ø³Ø® Ø§Ø² ZarinPal
type PaymentResponse struct {
    Data struct {
        Code      int    `json:"code"`
        Message   string `json:"message"`
        Authority string `json:"authority"`
        FeeType   string `json:"fee_type"`
        Fee       int    `json:"fee"`
    } `json:"data"`
    Errors []interface{} `json:"errors"`
}

// PaymentVerify - Ø³Ø§Ø®ØªØ§Ø± Ø¯Ø±Ø®ÙˆØ§Ø³Øª ØªØ§ÛŒÛŒØ¯
type PaymentVerify struct {
    MerchantID string `json:"merchant_id"`
    Amount     int    `json:"amount"`
    Authority  string `json:"authority"`
}

// PaymentVerifyResponse - Ù¾Ø§Ø³Ø® ØªØ§ÛŒÛŒØ¯ Ù¾Ø±Ø¯Ø§Ø®Øª
type PaymentVerifyResponse struct {
    Data struct {
        Code     int    `json:"code"`
        Message  string `json:"message"`
        RefID    int    `json:"ref_id"`
        CardPan  string `json:"card_pan"`
        CardHash string `json:"card_hash"`
        FeeType  string `json:"fee_type"`
        Fee      int    `json:"fee"`
    } `json:"data"`
    Errors []interface{} `json:"errors"`
}

// NewPaymentService creates a new payment service
func NewPaymentService(db *gorm.DB, cfg *config.PaymentConfig) *PaymentService {
    return &PaymentService{
        db:     db,
        config: cfg,
    }
}

// CreatePaymentRequest creates a payment request and returns transaction & payment URL
func (s *PaymentService) CreatePaymentRequest(
    userID uint, 
    paymentType string, 
    amount int, 
    description string,
) (*models.PaymentTransaction, string, error) {
    
    // 1. ØªÙˆÙ„ÛŒØ¯ Authority Ù…ÙˆÙ‚Øª (Ø¨Ø¹Ø¯Ø§Ù‹ Ø§Ø² ZarinPal Ø¯Ø±ÛŒØ§ÙØª Ù…ÛŒâ€ŒØ´ÙˆØ¯)
    authority := fmt.Sprintf("A%032d", time.Now().UnixNano())

    // 2. Ø§ÛŒØ¬Ø§Ø¯ Ø±Ú©ÙˆØ±Ø¯ ØªØ±Ø§Ú©Ù†Ø´ Ø¯Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³
    transaction := models.PaymentTransaction{
        UserID:      userID,
        Type:        paymentType, // "subscription" ÛŒØ§ "roadmap"
        Amount:      amount,
        Authority:   authority,
        Status:      "pending",
        Description: description,
    }

    if err := s.db.Create(&transaction).Error; err != nil {
        return nil, "", fmt.Errorf("failed to create payment transaction: %w", err)
    }

    // 3. Ø³Ø§Ø®Øª Ø¯Ø±Ø®ÙˆØ§Ø³Øª JSON Ø¨Ø±Ø§ÛŒ ZarinPal
    paymentReq := PaymentRequest{
        MerchantID:  s.config.MerchantID,
        Amount:      amount,
        Currency:    "IRT", // ØªÙˆÙ…Ø§Ù†
        Description: description,
        CallbackURL: s.config.CallbackURL,
        Metadata: struct {
            Mobile  string `json:"mobile,omitempty"`
            Email   string `json:"email,omitempty"`
            OrderID string `json:"order_id,omitempty"`
        }{
            OrderID: fmt.Sprintf("%d", transaction.ID),
        },
    }

    // 4. Ø§Ù†ØªØ®Ø§Ø¨ URL Ø¨Ø± Ø§Ø³Ø§Ø³ Sandbox Mode
    apiURL := "https://payment.zarinpal.com/pg/v4/payment/request.json"
    if s.config.Sandbox {
        apiURL = "https://sandbox.zarinpal.com/pg/v4/payment/request.json"
    }

    // 5. Ø§Ø±Ø³Ø§Ù„ Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø¨Ù‡ ZarinPal
    response, err := s.sendPaymentRequest(apiURL, paymentReq)
    if err != nil {
        return nil, "", fmt.Errorf("failed to send payment request: %w", err)
    }

    // 6. Ø¨Ø±Ø±Ø³ÛŒ Ù¾Ø§Ø³Ø® - Code 100 ÛŒØ¹Ù†ÛŒ Ù…ÙˆÙÙ‚
    if response.Data.Code != 100 {
        return nil, "", fmt.Errorf("payment request failed: %s", response.Data.Message)
    }

    // 7. Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ØªØ±Ø§Ú©Ù†Ø´ Ø¨Ø§ Authority ÙˆØ§Ù‚Ø¹ÛŒ Ø§Ø² ZarinPal
    transaction.Authority = response.Data.Authority
    if err := s.db.Save(&transaction).Error; err != nil {
        return nil, "", fmt.Errorf("failed to update transaction: %w", err)
    }

    // 8. Ø³Ø§Ø®Øª URL Ù¾Ø±Ø¯Ø§Ø®Øª Ø¨Ø±Ø§ÛŒ Ú©Ø§Ø±Ø¨Ø±
    paymentURL := fmt.Sprintf("https://payment.zarinpal.com/pg/StartPay/%s", response.Data.Authority)
    if s.config.Sandbox {
        paymentURL = fmt.Sprintf("https://sandbox.zarinpal.com/pg/StartPay/%s", response.Data.Authority)
    }

    return &transaction, paymentURL, nil
}

// sendPaymentRequest Ø§Ø±Ø³Ø§Ù„ Ø¯Ø±Ø®ÙˆØ§Ø³Øª HTTP POST Ø¨Ù‡ ZarinPal
func (s *PaymentService) sendPaymentRequest(url string, req PaymentRequest) (*PaymentResponse, error) {
    jsonData, err := json.Marshal(req)
    if err != nil {
        return nil, err
    }

    httpReq, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
    if err != nil {
        return nil, err
    }

    httpReq.Header.Set("Content-Type", "application/json")
    httpReq.Header.Set("Accept", "application/json")

    client := &http.Client{Timeout: 30 * time.Second}
    resp, err := client.Do(httpReq)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return nil, err
    }

    var response PaymentResponse
    if err := json.Unmarshal(body, &response); err != nil {
        return nil, err
    }

    return &response, nil
}

// VerifyPayment ØªØ§ÛŒÛŒØ¯ Ù¾Ø±Ø¯Ø§Ø®Øª Ø¨Ø§ ZarinPal
func (s *PaymentService) VerifyPayment(authority string, amount int) (*models.PaymentTransaction, error) {
    // 1. Ù¾ÛŒØ¯Ø§ Ú©Ø±Ø¯Ù† ØªØ±Ø§Ú©Ù†Ø´ Ø§Ø² Ø¯ÛŒØªØ§Ø¨ÛŒØ³
    var transaction models.PaymentTransaction
    if err := s.db.Where("authority = ?", authority).First(&transaction).Error; err != nil {
        return nil, fmt.Errorf("transaction not found: %w", err)
    }

    // 2. Ø³Ø§Ø®Øª Ø¯Ø±Ø®ÙˆØ§Ø³Øª ØªØ§ÛŒÛŒØ¯
    verifyReq := PaymentVerify{
        MerchantID: s.config.MerchantID,
        Amount:     amount,
        Authority:  authority,
    }

    // 3. Ø§Ù†ØªØ®Ø§Ø¨ URL
    apiURL := "https://api.zarinpal.com/pg/v4/payment/verify.json"
    if s.config.Sandbox {
        apiURL = "https://sandbox.zarinpal.com/pg/v4/payment/verify.json"
    }

    // 4. Ø§Ø±Ø³Ø§Ù„ Ø¯Ø±Ø®ÙˆØ§Ø³Øª ØªØ§ÛŒÛŒØ¯
    response, err := s.sendVerifyRequest(apiURL, verifyReq)
    if err != nil {
        return nil, fmt.Errorf("failed to verify payment: %w", err)
    }

    // 5. Ø¨Ø±Ø±Ø³ÛŒ Ú©Ø¯ Ù¾Ø§Ø³Ø® - 100 ÛŒØ§ 101 = Ù…ÙˆÙÙ‚
    if response.Data.Code == 100 || response.Data.Code == 101 {
        transaction.Status = "success"
        transaction.RefID = fmt.Sprintf("%d", response.Data.RefID)
    } else {
        transaction.Status = "failed"
    }

    // 6. Ø°Ø®ÛŒØ±Ù‡ ÙˆØ¶Ø¹ÛŒØª Ù†Ù‡Ø§ÛŒÛŒ
    if err := s.db.Save(&transaction).Error; err != nil {
        log.Printf("Failed to update transaction status: %v", err)
    }

    return &transaction, nil
}

// sendVerifyRequest Ø§Ø±Ø³Ø§Ù„ Ø¯Ø±Ø®ÙˆØ§Ø³Øª ØªØ§ÛŒÛŒØ¯ Ø¨Ù‡ ZarinPal
func (s *PaymentService) sendVerifyRequest(url string, req PaymentVerify) (*PaymentVerifyResponse, error) {
    jsonData, err := json.Marshal(req)
    if err != nil {
        return nil, err
    }

    httpReq, err := http.NewRequest("POST", url, bytes.NewBuffer(jsonData))
    if err != nil {
        return nil, err
    }

    httpReq.Header.Set("Content-Type", "application/json")
    httpReq.Header.Set("Accept", "application/json")

    client := &http.Client{Timeout: 30 * time.Second}
    resp, err := client.Do(httpReq)
    if err != nil {
        return nil, err
    }
    defer resp.Body.Close()

    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return nil, err
    }

    var response PaymentVerifyResponse
    if err := json.Unmarshal(body, &response); err != nil {
        return nil, err
    }

    return &response, nil
}

// UpdateUserSubscription Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø§Ø´ØªØ±Ø§Ú© Ú©Ø§Ø±Ø¨Ø± Ù¾Ø³ Ø§Ø² Ù¾Ø±Ø¯Ø§Ø®Øª Ù…ÙˆÙÙ‚
func (s *PaymentService) UpdateUserSubscription(userID uint, paymentType string) error {
    var user models.User
    if err := s.db.First(&user, userID).Error; err != nil {
        return err
    }

    switch paymentType {
    case "subscription":
        // Ø§ÙØ²ÙˆØ¯Ù† 30 Ø±ÙˆØ² Ø¨Ù‡ Ø§Ø´ØªØ±Ø§Ú©
        var subscriptionEnd time.Time
        if user.SubscriptionEnd != nil && user.SubscriptionEnd.After(time.Now()) {
            // ØªÙ…Ø¯ÛŒØ¯ Ø§Ø´ØªØ±Ø§Ú© ÙØ¹Ø§Ù„
            subscriptionEnd = user.SubscriptionEnd.AddDate(0, 0, 30)
        } else {
            // Ø´Ø±ÙˆØ¹ Ø§Ø´ØªØ±Ø§Ú© Ø¬Ø¯ÛŒØ¯
            subscriptionEnd = time.Now().AddDate(0, 0, 30)
        }
        user.SubscriptionEnd = &subscriptionEnd
        
    case "roadmap":
        // ÙØ¹Ø§Ù„ Ú©Ø±Ø¯Ù† Ø¯Ø³ØªØ±Ø³ÛŒ Ø±ÙˆØ¯Ù…Ù¾
        user.HasPaidRoadmap = true
    }

    return s.db.Save(&user).Error
}

// CheckUserSubscription Ø¨Ø±Ø±Ø³ÛŒ Ø§Ø´ØªØ±Ø§Ú© ÙØ¹Ø§Ù„
func (s *PaymentService) CheckUserSubscription(userID uint) bool {
    var user models.User
    if err := s.db.First(&user, userID).Error; err != nil {
        return false
    }

    if user.SubscriptionEnd == nil {
        return false
    }

    return user.SubscriptionEnd.After(time.Now())
}

// GetUserTransactions Ø¯Ø±ÛŒØ§ÙØª ØªØ§Ø±ÛŒØ®Ú†Ù‡ ØªØ±Ø§Ú©Ù†Ø´â€ŒÙ‡Ø§ÛŒ Ú©Ø§Ø±Ø¨Ø±
func (s *PaymentService) GetUserTransactions(userID uint) ([]models.PaymentTransaction, error) {
    var transactions []models.PaymentTransaction
    err := s.db.Where("user_id = ?", userID).
        Order("created_at DESC").
        Find(&transactions).Error
    return transactions, err
}
```

### 4.3 Ù…Ø±Ø­Ù„Ù‡ 3: Ø³Ø§Ø®Øª PaymentCallbackHandler

**ÙØ§ÛŒÙ„:** `handlers/payment_callback.go`

```go
package handlers

import (
    "avangard_ai_bot/keyboards"
    "avangard_ai_bot/messages"
    "avangard_ai_bot/models"
    "avangard_ai_bot/services"
    "encoding/json"
    "fmt"
    "log"
    "net/http"
    "time"

    tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
    "gorm.io/gorm"
)

// PaymentCallbackHandler handles payment callbacks from ZarinPal
type PaymentCallbackHandler struct {
    bot            *tgbotapi.BotAPI
    db             *gorm.DB
    paymentService *services.PaymentService
}

// NewPaymentCallbackHandler creates a new callback handler
func NewPaymentCallbackHandler(
    bot *tgbotapi.BotAPI,
    db *gorm.DB,
    paymentService *services.PaymentService,
) *PaymentCallbackHandler {
    return &PaymentCallbackHandler{
        bot:            bot,
        db:             db,
        paymentService: paymentService,
    }
}

// HandleCallback processes the ZarinPal callback
func (h *PaymentCallbackHandler) HandleCallback(w http.ResponseWriter, r *http.Request) {
    // 1. Ø¯Ø±ÛŒØ§ÙØª Ù¾Ø§Ø±Ø§Ù…ØªØ±Ù‡Ø§ Ø§Ø² Query String
    authority := r.URL.Query().Get("Authority")
    status := r.URL.Query().Get("Status")

    log.Printf("Payment callback - Authority: %s, Status: %s", authority, status)

    // 2. Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¬ÙˆØ¯ Authority
    if authority == "" {
        log.Printf("No authority provided")
        h.renderPaymentPage(w, r, "failed", "Ú©Ø¯ Ù¾ÛŒÚ¯ÛŒØ±ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯", "NO_AUTHORITY", "", "", "")
        return
    }

    // 3. Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¶Ø¹ÛŒØª OK (Ø§Ú¯Ø± Status != "OK" ÛŒØ¹Ù†ÛŒ Ú©Ø§Ø±Ø¨Ø± Ù¾Ø±Ø¯Ø§Ø®Øª Ø±Ø§ Ù„ØºÙˆ Ú©Ø±Ø¯Ù‡)
    if status != "OK" {
        log.Printf("Payment cancelled by user: %s", status)
        h.renderPaymentPage(w, r, "failed", "Ù¾Ø±Ø¯Ø§Ø®Øª Ù„ØºÙˆ Ø´Ø¯", "CANCELLED", "", "", "")
        return
    }

    // 4. Ù¾ÛŒØ¯Ø§ Ú©Ø±Ø¯Ù† ØªØ±Ø§Ú©Ù†Ø´ Ø¯Ø± Ø¯ÛŒØªØ§Ø¨ÛŒØ³
    var transaction models.PaymentTransaction
    if err := h.db.Where("authority = ?", authority).First(&transaction).Error; err != nil {
        log.Printf("Transaction not found: %s", authority)
        h.renderPaymentPage(w, r, "failed", "ØªØ±Ø§Ú©Ù†Ø´ ÛŒØ§ÙØª Ù†Ø´Ø¯", "NOT_FOUND", "", "", "")
        return
    }

    // 5. Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù…Ø¬Ø¯Ø¯ (Idempotency)
    if transaction.Status == "success" {
        log.Printf("Transaction already processed: %s", authority)
        h.renderPaymentPage(w, r, "success", 
            "Ù¾Ø±Ø¯Ø§Ø®Øª Ù‚Ø¨Ù„Ø§Ù‹ ØªØ£ÛŒÛŒØ¯ Ø´Ø¯Ù‡ Ø§Ø³Øª", "ALREADY_PROCESSED",
            transaction.RefID, fmt.Sprintf("%d", transaction.Amount), transaction.Type)
        return
    }

    // 6. ØªØ§ÛŒÛŒØ¯ Ù¾Ø±Ø¯Ø§Ø®Øª Ø¨Ø§ ZarinPal
    verifiedTransaction, err := h.paymentService.VerifyPayment(authority, transaction.Amount)
    if err != nil {
        log.Printf("Payment verification failed: %v", err)
        h.renderPaymentPage(w, r, "failed", 
            "ØªØ£ÛŒÛŒØ¯ Ù¾Ø±Ø¯Ø§Ø®Øª Ù†Ø§Ù…ÙˆÙÙ‚ Ø¨ÙˆØ¯", "VERIFICATION_FAILED", "", "", "")
        return
    }

    // 7. Ø¨Ø±Ø±Ø³ÛŒ Ù†ØªÛŒØ¬Ù‡ ØªØ§ÛŒÛŒØ¯
    if verifiedTransaction.Status != "success" {
        log.Printf("Payment not verified: %s", verifiedTransaction.Status)
        h.renderPaymentPage(w, r, "failed", 
            "Ù¾Ø±Ø¯Ø§Ø®Øª ØªØ£ÛŒÛŒØ¯ Ù†Ø´Ø¯", "NOT_VERIFIED", "", "", "")
        return
    }

    // 8. Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø§Ø´ØªØ±Ø§Ú©/Ø¯Ø³ØªØ±Ø³ÛŒ Ú©Ø§Ø±Ø¨Ø±
    if err := h.paymentService.UpdateUserSubscription(
        verifiedTransaction.UserID,
        verifiedTransaction.Type,
    ); err != nil {
        log.Printf("Failed to update subscription: %v", err)
        // Ø§Ø¯Ø§Ù…Ù‡ Ù…ÛŒâ€ŒØ¯Ù‡ÛŒÙ… Ø­ØªÛŒ Ø§Ú¯Ø± Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ø§Ø´ØªØ±Ø§Ú© Ø®Ø·Ø§ Ø¯Ø§Ø¯
    }

    // 9. Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡ Ú©Ø§Ø±Ø¨Ø± Ø¯Ø± ÙˆØ¨Ø³Ø§ÛŒØª
    h.sendPaymentSuccessNotification(verifiedTransaction.UserID, verifiedTransaction)

    // 10. Ù†Ù…Ø§ÛŒØ´ ØµÙØ­Ù‡ Ù…ÙˆÙÙ‚ÛŒØª
    h.renderPaymentPage(w, r, "success",
        "Ù¾Ø±Ø¯Ø§Ø®Øª Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯", "SUCCESS",
        verifiedTransaction.RefID,
        fmt.Sprintf("%d", verifiedTransaction.Amount),
        verifiedTransaction.Type)
}

// sendPaymentSuccessNotification Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡ Ú©Ø§Ø±Ø¨Ø±
func (h *PaymentCallbackHandler) sendPaymentSuccessNotification(
    userID uint,
    transaction *models.PaymentTransaction,
) {
    // Ø¯Ø±ÛŒØ§ÙØª Ø§Ø·Ù„Ø§Ø¹Ø§Øª Ú©Ø§Ø±Ø¨Ø±
    var user models.User
    if err := h.db.First(&user, userID).Error; err != nil {
        log.Printf("Error getting user: %v", err)
        return
    }

    // Ø³Ø§Ø®Øª Ù¾ÛŒØ§Ù… Ù…ÙˆÙÙ‚ÛŒØª
    var successMessage string
    if transaction.Type == "subscription" {
        // Ø¯Ø±ÛŒØ§ÙØª ØªØ§Ø±ÛŒØ® Ø§Ù†Ù‚Ø¶Ø§ÛŒ Ø¬Ø¯ÛŒØ¯
        var userWithSub models.User
        if err := h.db.First(&userWithSub, transaction.UserID).Error; err == nil &&
            userWithSub.SubscriptionEnd != nil {
            successMessage = fmt.Sprintf(
                "âœ… *Ù¾Ø±Ø¯Ø§Ø®Øª Ù…ÙˆÙÙ‚!*\n\n"+
                    "ğŸ“‹ Ø´Ù…Ø§Ø±Ù‡ ØªØ±Ø§Ú©Ù†Ø´: %s\n"+
                    "ğŸ’° Ù…Ø¨Ù„Øº: %d ØªÙˆÙ…Ø§Ù†\n"+
                    "ğŸ Ù†ÙˆØ¹: Ø§Ø´ØªØ±Ø§Ú© ÛŒÚ© Ù…Ø§Ù‡Ù‡\n"+
                    "ğŸ“… ØªØ§Ø±ÛŒØ® Ø§Ù†Ù‚Ø¶Ø§ÛŒ Ø¬Ø¯ÛŒØ¯: %s\n\n"+
                    "Ø§Ø² Ø®Ø¯Ù…Ø§Øª Ù…Ø§ Ù„Ø°Øª Ø¨Ø¨Ø±ÛŒØ¯! ğŸ‰",
                transaction.RefID,
                transaction.Amount,
                userWithSub.SubscriptionEnd.Format("2006-01-02 15:04"))
        } else {
            successMessage = fmt.Sprintf(
                "âœ… *Ù¾Ø±Ø¯Ø§Ø®Øª Ù…ÙˆÙÙ‚!*\n\n"+
                    "ğŸ“‹ Ø´Ù…Ø§Ø±Ù‡ ØªØ±Ø§Ú©Ù†Ø´: %s\n"+
                    "ğŸ’° Ù…Ø¨Ù„Øº: %d ØªÙˆÙ…Ø§Ù†\n"+
                    "ğŸ Ù†ÙˆØ¹: Ø§Ø´ØªØ±Ø§Ú© ÛŒÚ© Ù…Ø§Ù‡Ù‡\n\n"+
                    "Ø§Ø² Ø®Ø¯Ù…Ø§Øª Ù…Ø§ Ù„Ø°Øª Ø¨Ø¨Ø±ÛŒØ¯! ğŸ‰",
                transaction.RefID,
                transaction.Amount)
        }
    } else {
        successMessage = fmt.Sprintf(
            "âœ… *Ù¾Ø±Ø¯Ø§Ø®Øª Ù…ÙˆÙÙ‚!*\n\n"+
                "ğŸ“‹ Ø´Ù…Ø§Ø±Ù‡ ØªØ±Ø§Ú©Ù†Ø´: %s\n"+
                "ğŸ’° Ù…Ø¨Ù„Øº: %d ØªÙˆÙ…Ø§Ù†\n"+
                "ğŸ Ù†ÙˆØ¹: Ø±ÙˆØ¯Ù…Ù¾ Ø§Ø®ØªØµØ§ØµÛŒ\n\n"+
                "Ø§Ø² Ø®Ø¯Ù…Ø§Øª Ù…Ø§ Ù„Ø°Øª Ø¨Ø¨Ø±ÛŒØ¯! ğŸ‰",
            transaction.RefID,
            transaction.Amount)
    }

    // Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù…
    msg := tgbotapi.NewMessage(int64(user.TelegramID), successMessage)
    msg.ParseMode = "Markdown"
    keyboard := keyboards.MainMenuKeyboard()
    msg.ReplyMarkup = &keyboard

    if _, err := h.bot.Send(msg); err != nil {
        log.Printf("Error sending notification: %v", err)
    }
}

// renderPaymentPage Ù†Ù…Ø§ÛŒØ´ ØµÙØ­Ù‡ Ù†ØªÛŒØ¬Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª
func (h *PaymentCallbackHandler) renderPaymentPage(
    w http.ResponseWriter,
    r *http.Request,
    status, message, code, refID, amount, paymentType string,
) {
    w.Header().Set("Content-Type", "text/html; charset=utf-8")

    var redirectURL string

    switch status {
    case "success":
        redirectURL = fmt.Sprintf("/payment/success?ref_id=%s&amount=%s&type=%s",
            refID, amount, paymentType)
    case "failed":
        redirectURL = fmt.Sprintf("/payment/failed?error=%s&code=%s", message, code)
    default:
        redirectURL = fmt.Sprintf("/payment/pending?authority=%s", refID)
    }

    http.Redirect(w, r, redirectURL, http.StatusSeeOther)
}

// CheckPaymentStatus Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¶Ø¹ÛŒØª Ù¾Ø±Ø¯Ø§Ø®Øª (API endpoint)
func (h *PaymentCallbackHandler) CheckPaymentStatus(w http.ResponseWriter, r *http.Request) {
    authority := r.URL.Query().Get("authority")
    if authority == "" {
        http.Error(w, "Authority required", http.StatusBadRequest)
        return
    }

    var transaction models.PaymentTransaction
    if err := h.db.Where("authority = ?", authority).First(&transaction).Error; err != nil {
        response := map[string]interface{}{
            "success": false,
            "pending": true,
            "error":   "Transaction not found",
        }
        w.Header().Set("Content-Type", "application/json")
        json.NewEncoder(w).Encode(response)
        return
    }

    response := map[string]interface{}{
        "success": transaction.Status == "success",
        "failed":  transaction.Status == "failed",
        "pending": transaction.Status == "pending",
        "ref_id":  transaction.RefID,
        "amount":  transaction.Amount,
        "type":    transaction.Type,
    }

    w.Header().Set("Content-Type", "application/json")
    json.NewEncoder(w).Encode(response)
}
```

### 4.4 Ù…Ø±Ø­Ù„Ù‡ 4: Ø§ÙØ²ÙˆØ¯Ù† Ù‡Ù†Ø¯Ù„Ø±Ù‡Ø§ÛŒ Ø±Ø¨Ø§Øª

**ÙØ§ÛŒÙ„:** `handlers/handlers.go` (Ø¨Ø®Ø´ Ù¾Ø±Ø¯Ø§Ø®Øª)

```go
// handlePaymentButton - Ù†Ù…Ø§ÛŒØ´ Ù…Ù†ÙˆÛŒ Ù¾Ø±Ø¯Ø§Ø®Øª
func (h *BotHandler) handlePaymentButton(message *tgbotapi.Message, user *models.User) {
    paymentText := "ğŸ’³ *Ù…Ø±Ú©Ø² Ù¾Ø±Ø¯Ø§Ø®Øª*\n\n" +
        "Ø®Ø¯Ù…Ø§Øª Ù¾ÙˆÙ„ÛŒ Ø±Ø¨Ø§Øª:\n\n" +
        "ğŸ”¹ Ø§Ø´ØªØ±Ø§Ú© Ù…Ø§Ù‡ÛŒØ§Ù†Ù‡: Ø¯Ø³ØªØ±Ø³ÛŒ Ú©Ø§Ù…Ù„\n" +
        "ğŸ”¹ Ø±ÙˆØ¯Ù…Ù¾ Ø§Ø®ØªØµØ§ØµÛŒ: Ù†Ù‚Ø´Ù‡ Ø±Ø§Ù‡ Ø´Ø®ØµÛŒ\n\n" +
        "ÛŒÚ©ÛŒ Ø§Ø² Ú¯Ø²ÛŒÙ†Ù‡â€ŒÙ‡Ø§ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯:"

    msg := tgbotapi.NewMessage(message.Chat.ID, paymentText)
    msg.ParseMode = "Markdown"
    keyboard := keyboards.PaymentKeyboard()
    msg.ReplyMarkup = &keyboard

    h.bot.Send(msg)
}

// handleSubscriptionPaymentButton - Ø§ÛŒØ¬Ø§Ø¯ Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ù¾Ø±Ø¯Ø§Ø®Øª Ø§Ø´ØªØ±Ø§Ú©
func (h *BotHandler) handleSubscriptionPaymentButton(
    message *tgbotapi.Message,
    user *models.User,
) {
    paymentService := services.NewPaymentService(h.db, &h.config.Payment)

    // Ø¨Ø±Ø±Ø³ÛŒ Ø§Ø´ØªØ±Ø§Ú© ÙØ¹Ø§Ù„
    hasActiveSubscription := paymentService.CheckUserSubscription(user.ID)

    amount := h.config.Payment.SubscriptionPrice
    description := "Ø§Ø´ØªØ±Ø§Ú© Ù…Ø§Ù‡ÛŒØ§Ù†Ù‡ Ø±Ø¨Ø§Øª Ø¢ÙˆØ§Ù†Ú¯Ø§Ø±Ø¯"

    if hasActiveSubscription {
        description = "ØªÙ…Ø¯ÛŒØ¯ Ø§Ø´ØªØ±Ø§Ú© Ù…Ø§Ù‡ÛŒØ§Ù†Ù‡"
    }

    // Ø§ÛŒØ¬Ø§Ø¯ Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ù¾Ø±Ø¯Ø§Ø®Øª
    _, paymentURL, err := paymentService.CreatePaymentRequest(
        user.ID,
        "subscription",
        amount,
        description,
    )

    if err != nil {
        log.Printf("Error creating payment: %v", err)
        h.sendErrorMessage(message.Chat.ID, "âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ù¾Ø±Ø¯Ø§Ø®Øª")
        return
    }

    // Ø§Ø±Ø³Ø§Ù„ Ù„ÛŒÙ†Ú© Ù¾Ø±Ø¯Ø§Ø®Øª Ø¨Ù‡ Ú©Ø§Ø±Ø¨Ø±
    paymentText := fmt.Sprintf(
        "ğŸ’³ *Ø§Ø´ØªØ±Ø§Ú© Ù…Ø§Ù‡ÛŒØ§Ù†Ù‡*\n\n"+
            "Ù‚ÛŒÙ…Øª: %d ØªÙˆÙ…Ø§Ù†\n\n"+
            "ğŸ”— *Ù„ÛŒÙ†Ú© Ù¾Ø±Ø¯Ø§Ø®Øª:*\n%s\n\n"+
            "âš ï¸ *ØªÙˆØ¬Ù‡:* Ù¾Ø±Ø¯Ø§Ø®Øª Ø±Ø§ Ø¯Ø± Ú©Ù…ØªØ± Ø§Ø² 15 Ø¯Ù‚ÛŒÙ‚Ù‡ ØªÚ©Ù…ÛŒÙ„ Ú©Ù†ÛŒØ¯.",
        amount, paymentURL)

    msg := tgbotapi.NewMessage(message.Chat.ID, paymentText)
    msg.ParseMode = "Markdown"

    // Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§ÛŒ Ø§ÛŒÙ†Ù„Ø§ÛŒÙ† Ø¨Ø±Ø§ÛŒ Ù¾Ø±Ø¯Ø§Ø®Øª
    keyboard := tgbotapi.NewInlineKeyboardMarkup(
        tgbotapi.NewInlineKeyboardRow(
            tgbotapi.NewInlineKeyboardButtonURL("ğŸ’³ Ù¾Ø±Ø¯Ø§Ø®Øª", paymentURL),
        ),
    )
    msg.ReplyMarkup = keyboard

    h.bot.Send(msg)
}

// handleRoadmapPaymentButton - Ø§ÛŒØ¬Ø§Ø¯ Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ù¾Ø±Ø¯Ø§Ø®Øª Ø±ÙˆØ¯Ù…Ù¾
func (h *BotHandler) handleRoadmapPaymentButton(
    message *tgbotapi.Message,
    user *models.User,
) {
    paymentService := services.NewPaymentService(h.db, &h.config.Payment)

    amount := h.config.Payment.RoadmapPrice
    description := "Ø±ÙˆØ¯Ù…Ù¾ Ø§Ø®ØªØµØ§ØµÛŒ Ø±Ø¨Ø§Øª Ø¢ÙˆØ§Ù†Ú¯Ø§Ø±Ø¯"

    _, paymentURL, err := paymentService.CreatePaymentRequest(
        user.ID,
        "roadmap",
        amount,
        description,
    )

    if err != nil {
        log.Printf("Error creating payment: %v", err)
        h.sendErrorMessage(message.Chat.ID, "âŒ Ø®Ø·Ø§ Ø¯Ø± Ø§ÛŒØ¬Ø§Ø¯ Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ù¾Ø±Ø¯Ø§Ø®Øª")
        return
    }

    paymentText := fmt.Sprintf(
        "ğŸ—ºï¸ *Ø±ÙˆØ¯Ù…Ù¾ Ø§Ø®ØªØµØ§ØµÛŒ*\n\n"+
            "Ù‚ÛŒÙ…Øª: %d ØªÙˆÙ…Ø§Ù†\n\n"+
            "ğŸ”— *Ù„ÛŒÙ†Ú© Ù¾Ø±Ø¯Ø§Ø®Øª:*\n%s\n\n"+
            "âš ï¸ *ØªÙˆØ¬Ù‡:* Ù¾Ø±Ø¯Ø§Ø®Øª Ø±Ø§ Ø¯Ø± Ú©Ù…ØªØ± Ø§Ø² 15 Ø¯Ù‚ÛŒÙ‚Ù‡ ØªÚ©Ù…ÛŒÙ„ Ú©Ù†ÛŒØ¯.",
        amount, paymentURL)

    msg := tgbotapi.NewMessage(message.Chat.ID, paymentText)
    msg.ParseMode = "Markdown"

    keyboard := tgbotapi.NewInlineKeyboardMarkup(
        tgbotapi.NewInlineKeyboardRow(
            tgbotapi.NewInlineKeyboardButtonURL("ğŸ’³ Ù¾Ø±Ø¯Ø§Ø®Øª", paymentURL),
        ),
    )
    msg.ReplyMarkup = keyboard

    h.bot.Send(msg)
}

// checkSubscriptionRequirement - Ø¨Ø±Ø±Ø³ÛŒ Ù†ÛŒØ§Ø² Ø¨Ù‡ Ø§Ø´ØªØ±Ø§Ú©
func (h *BotHandler) checkSubscriptionRequirement(
    message *tgbotapi.Message,
    user *models.User,
) bool {
    paymentService := services.NewPaymentService(h.db, &h.config.Payment)

    if !paymentService.CheckUserSubscription(user.ID) {
        msg := tgbotapi.NewMessage(
            message.Chat.ID,
            "ğŸ”’ *Ø§Ø´ØªØ±Ø§Ú© Ù…Ù†Ù‚Ø¶ÛŒ Ø´Ø¯Ù‡!*\n\n"+
                "Ø¨Ø±Ø§ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ø§ÛŒÙ† Ù‚Ø§Ø¨Ù„ÛŒØªØŒ Ù„Ø·ÙØ§Ù‹ Ø§Ø´ØªØ±Ø§Ú© Ø±Ø§ ØªÙ…Ø¯ÛŒØ¯ Ú©Ù†ÛŒØ¯.",
        )
        msg.ParseMode = "Markdown"
        keyboard := keyboards.PaymentKeyboard()
        msg.ReplyMarkup = &keyboard
        h.bot.Send(msg)
        return false
    }

    return true
}
```

### 4.5 Ù…Ø±Ø­Ù„Ù‡ 5: Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ HTTP Server

**ÙØ§ÛŒÙ„:** `main.go`

```go
package main

import (
    "avangard_ai_bot/config"
    "avangard_ai_bot/database"
    "avangard_ai_bot/handlers"
    "avangard_ai_bot/services"
    "log"
    "net/http"

    tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
)

func main() {
    // 1. Ø¨Ø§Ø±Ú¯Ø°Ø§Ø±ÛŒ ØªÙ†Ø¸ÛŒÙ…Ø§Øª
    cfg, err := config.LoadConfig()
    if err != nil {
        log.Fatalf("Failed to load config: %v", err)
    }

    // 2. Ø§ØªØµØ§Ù„ Ø¨Ù‡ Ø¯ÛŒØªØ§Ø¨ÛŒØ³
    if err := database.InitDB(cfg); err != nil {
        log.Fatalf("Failed to initialize database: %v", err)
    }

    // 3. Ø§ÛŒØ¬Ø§Ø¯ Ø±Ø¨Ø§Øª
    bot, err := tgbotapi.NewBotAPI(cfg.Bot.Token)
    if err != nil {
        log.Fatalf("Failed to create bot: %v", err)
    }

    // 4. Ø§ÛŒØ¬Ø§Ø¯ Ø³Ø±ÙˆÛŒØ³ Ù¾Ø±Ø¯Ø§Ø®Øª
    paymentService := services.NewPaymentService(database.GetDB(), &cfg.Payment)

    // 5. Ø§ÛŒØ¬Ø§Ø¯ Ù‡Ù†Ø¯Ù„Ø± Ú©Ø§Ù„Ø¨Ú©
    paymentCallbackHandler := handlers.NewPaymentCallbackHandler(
        bot,
        database.GetDB(),
        paymentService,
    )

    // 6. ØªÙ†Ø¸ÛŒÙ… Routes Ø¨Ø±Ø§ÛŒ Callback
    http.HandleFunc("/payment/callback", paymentCallbackHandler.HandleCallback)
    http.HandleFunc("/payment/check", paymentCallbackHandler.CheckPaymentStatus)

    // 7. Routes Ø¨Ø±Ø§ÛŒ ØµÙØ­Ø§Øª HTML
    http.HandleFunc("/payment/success", func(w http.ResponseWriter, r *http.Request) {
        http.ServeFile(w, r, "static/payment_success.html")
    })
    http.HandleFunc("/payment/failed", func(w http.ResponseWriter, r *http.Request) {
        http.ServeFile(w, r, "static/payment_failed.html")
    })
    http.HandleFunc("/payment/pending", func(w http.ResponseWriter, r *http.Request) {
        http.ServeFile(w, r, "static/payment_pending.html")
    })

    // 8. Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø³Ø±ÙˆØ± HTTP (Ø¨Ø±Ø§ÛŒ Let's Encrypt)
    go func() {
        log.Printf("Starting HTTP server on port %s", cfg.Server.Port)
        if err := http.ListenAndServe(cfg.Server.Port, nil); err != nil {
            log.Fatalf("Failed to start HTTP server: %v", err)
        }
    }()

    // 9. Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø³Ø±ÙˆØ± HTTPS (Ø¨Ø±Ø§ÛŒ ZarinPal callbacks)
    go func() {
        sslService := services.NewSSLService(cfg.Server.Domain)
        if sslService.ValidateSSL() {
            certPath, keyPath := sslService.GetCertificatePath()
            log.Printf("Starting HTTPS server on port 443")
            log.Printf("Callback URL: %s", cfg.Payment.CallbackURL)
            if err := http.ListenAndServeTLS(":443", certPath, keyPath, nil); err != nil {
                log.Printf("Failed to start HTTPS server: %v", err)
            }
        } else {
            log.Printf("âš ï¸ Warning: SSL not available, callbacks may fail!")
        }
    }()

    // 10. Ø´Ø±ÙˆØ¹ Ø±Ø¨Ø§Øª (polling)
    u := tgbotapi.NewUpdate(0)
    u.Timeout = 60
    updates := bot.GetUpdatesChan(u)

    botHandler := handlers.NewBotHandler(bot, nil, cfg)

    for update := range updates {
        go botHandler.HandleUpdate(update)
    }
}
```

---

## 5. ØªÙ†Ø¸ÛŒÙ…Ø§Øª SSL Ùˆ HTTPS

### 5.1 Ú†Ø±Ø§ SSL Ù„Ø§Ø²Ù… Ø§Ø³ØªØŸ

ZarinPal Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„ callback Ø¨Ù‡ URL Ø´Ù…Ø§ Ù†ÛŒØ§Ø² Ø¨Ù‡ HTTPS Ø¯Ø§Ø±Ø¯. Ø¨Ø¯ÙˆÙ† SSLØŒ callback Ú©Ø§Ø± Ù†Ù…ÛŒâ€ŒÚ©Ù†Ø¯.

### 5.2 Ù†ØµØ¨ SSL Ø¨Ø§ Let's Encrypt

**Ø±ÙˆØ´ 1: Ø¯Ø³ØªÛŒ**

```bash
# Ù†ØµØ¨ certbot
sudo yum install certbot -y

# Ø¯Ø±ÛŒØ§ÙØª Ú¯ÙˆØ§Ù‡ÛŒÙ†Ø§Ù…Ù‡
sudo certbot certonly --standalone -d yourdomain.com

# Ú¯ÙˆØ§Ù‡ÛŒÙ†Ø§Ù…Ù‡â€ŒÙ‡Ø§ Ø¯Ø± Ø§ÛŒÙ† Ù…Ø³ÛŒØ± Ø°Ø®ÛŒØ±Ù‡ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯:
# /etc/letsencrypt/live/yourdomain.com/fullchain.pem
# /etc/letsencrypt/live/yourdomain.com/privkey.pem
```

**Ø±ÙˆØ´ 2: Ø¨Ø§ SSLService (Ø®ÙˆØ¯Ú©Ø§Ø±)**

```go
// Ø¯Ø± main.go
sslService := services.NewSSLService(cfg.Server.Domain)

if !sslService.ValidateSSL() {
    log.Printf("Installing SSL certificate...")
    if err := sslService.InstallLetsEncrypt(); err != nil {
        log.Printf("Failed to install SSL: %v", err)
    }
}
```

### 5.3 ØªÙ†Ø¸ÛŒÙ… Auto-Renewal

```bash
# Ø§ÙØ²ÙˆØ¯Ù† Ø¨Ù‡ crontab
0 0 * * * certbot renew --quiet --deploy-hook "systemctl restart your-service"
```

---

## 6. Ø¬Ø±ÛŒØ§Ù† Ú©Ø§Ù…Ù„ Ù¾Ø±Ø¯Ø§Ø®Øª

### 6.1 ÙÙ„ÙˆÛŒ Ú©Ø§Ù…Ù„ (Ø¨Ø§ Ù…Ø«Ø§Ù„)

```
1. Ú©Ø§Ø±Ø¨Ø± Ú©Ù„ÛŒÚ© Ù…ÛŒâ€ŒÚ©Ù†Ø¯: "ğŸ’³ Ø§Ø´ØªØ±Ø§Ú© Ù…Ø§Ù‡ÛŒØ§Ù†Ù‡"
   â†“
2. handleSubscriptionPaymentButton Ø§Ø¬Ø±Ø§ Ù…ÛŒâ€ŒØ´ÙˆØ¯
   â†“
3. CreatePaymentRequest:
   - Ø§ÛŒØ¬Ø§Ø¯ ØªØ±Ø§Ú©Ù†Ø´ Ø¯Ø± DB (status: "pending")
   - Ø§Ø±Ø³Ø§Ù„ Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø¨Ù‡ ZarinPal API
   - Ø¯Ø±ÛŒØ§ÙØª Authority
   - Ø¨Ø§Ø²Ú¯Ø´Øª URL Ù¾Ø±Ø¯Ø§Ø®Øª
   â†“
4. Ø§Ø±Ø³Ø§Ù„ URL Ø¨Ù‡ Ú©Ø§Ø±Ø¨Ø± Ø¯Ø± ÙˆØ¨Ø³Ø§ÛŒØª
   â†“
5. Ú©Ø§Ø±Ø¨Ø± Ø±ÙˆÛŒ Ù„ÛŒÙ†Ú© Ú©Ù„ÛŒÚ© Ù…ÛŒâ€ŒÚ©Ù†Ø¯ Ùˆ Ø¨Ù‡ ØµÙØ­Ù‡ Ù¾Ø±Ø¯Ø§Ø®Øª Ù…ÛŒâ€ŒØ±ÙˆØ¯
   â†“
6. Ú©Ø§Ø±Ø¨Ø± Ù¾Ø±Ø¯Ø§Ø®Øª Ø±Ø§ ØªÚ©Ù…ÛŒÙ„ Ù…ÛŒâ€ŒÚ©Ù†Ø¯
   â†“
7. ZarinPal Ø¨Ù‡ Callback URL Ù…Ø§ Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ù…ÛŒâ€ŒÙØ±Ø³ØªØ¯:
   GET /payment/callback?Authority=A000000...&Status=OK
   â†“
8. HandleCallback Ø§Ø¬Ø±Ø§ Ù…ÛŒâ€ŒØ´ÙˆØ¯:
   - Ø¨Ø±Ø±Ø³ÛŒ Authority Ùˆ Status
   - Ù¾ÛŒØ¯Ø§ Ú©Ø±Ø¯Ù† ØªØ±Ø§Ú©Ù†Ø´ Ø¯Ø± DB
   - VerifyPayment Ø¨Ø§ ZarinPal
   - Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ ÙˆØ¶Ø¹ÛŒØª ØªØ±Ø§Ú©Ù†Ø´ (success/failed)
   - UpdateUserSubscription
   - Ø§Ø±Ø³Ø§Ù„ Ù¾ÛŒØ§Ù… Ù…ÙˆÙÙ‚ÛŒØª Ø¨Ù‡ Ú©Ø§Ø±Ø¨Ø±
   - Redirect Ø¨Ù‡ ØµÙØ­Ù‡ success
   â†“
9. Ú©Ø§Ø±Ø¨Ø± Ø¨Ù‡ ØµÙØ­Ù‡ Ù…ÙˆÙÙ‚ÛŒØª Ù‡Ø¯Ø§ÛŒØª Ù…ÛŒâ€ŒØ´ÙˆØ¯
```

### 6.2 Ú©Ø¯Ù‡Ø§ÛŒ Ø®Ø·Ø§ ZarinPal

| Code | Ù…Ø¹Ù†ÛŒ |
|------|------|
| 100 | Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ù¾Ø±Ø¯Ø§Ø®Øª Ù…ÙˆÙÙ‚ |
| 101 | Ù¾Ø±Ø¯Ø§Ø®Øª Ù‚Ø¨Ù„Ø§Ù‹ ØªØ§ÛŒÛŒØ¯ Ø´Ø¯Ù‡ |
| -9 | Ø®Ø·Ø§ÛŒ Ø§Ø¹ØªØ¨Ø§Ø±Ø³Ù†Ø¬ÛŒ |
| -10 | IP ÛŒØ§ Ù…Ø±Ú†Ù†Øª Ú©Ø¯ Ù†Ø§Ù…Ø¹ØªØ¨Ø± |
| -11 | Ø¯Ø±Ú¯Ø§Ù‡ ÙØ¹Ø§Ù„ Ù†ÛŒØ³Øª |

---

## 7. ØªØ³Øª Ùˆ Ø¯Ø¨ÛŒØ§Ú¯

### 7.1 ØªØ³Øª Ø¯Ø± Ø­Ø§Ù„Øª Sandbox

```yaml
# config.yaml
payment:
  sandbox: true  # ÙØ¹Ø§Ù„ Ú©Ø±Ø¯Ù† Ø­Ø§Ù„Øª ØªØ³Øª
  merchant_id: "your-sandbox-merchant-id"
```

**Ú©Ø§Ø±Øªâ€ŒÙ‡Ø§ÛŒ ØªØ³Øª ZarinPal:**
- Ø´Ù…Ø§Ø±Ù‡ Ú©Ø§Ø±Øª: `6037-9970-0000-0000`
- CVV2: `123`
- ØªØ§Ø±ÛŒØ® Ø§Ù†Ù‚Ø¶Ø§: Ù‡Ø± ØªØ§Ø±ÛŒØ®ÛŒ Ø¯Ø± Ø¢ÛŒÙ†Ø¯Ù‡

### 7.2 Ù„Ø§Ú¯â€ŒÙ‡Ø§ÛŒ Ù…Ù‡Ù…

```go
// Ø¯Ø± PaymentService
log.Printf("Creating payment request - UserID: %d, Type: %s, Amount: %d", 
    userID, paymentType, amount)

log.Printf("ZarinPal response - Code: %d, Authority: %s", 
    response.Data.Code, response.Data.Authority)

// Ø¯Ø± PaymentCallbackHandler
log.Printf("Callback received - Authority: %s, Status: %s", authority, status)
log.Printf("Transaction verified - Status: %s, RefID: %s", 
    transaction.Status, transaction.RefID)
```

### 7.3 ØªØ³Øª Endpoint

```bash
# ØªØ³Øª callback
curl "https://yourdomain.com/payment/callback?Authority=A000000&Status=OK"

# Ø¨Ø±Ø±Ø³ÛŒ ÙˆØ¶Ø¹ÛŒØª
curl "https://yourdomain.com/payment/check?authority=A000000"
```

### 7.4 Ù…Ø´Ú©Ù„Ø§Øª Ø±Ø§ÛŒØ¬

**Ù…Ø´Ú©Ù„ 1: Callback Ø¯Ø±ÛŒØ§ÙØª Ù†Ù…ÛŒâ€ŒØ´ÙˆØ¯**
- âœ… Ø¨Ø±Ø±Ø³ÛŒ SSL Ùˆ HTTPS
- âœ… Ø¨Ø±Ø±Ø³ÛŒ Callback URL Ø¯Ø± Ù¾Ù†Ù„ ZarinPal
- âœ… Ø¨Ø±Ø±Ø³ÛŒ ÙØ§ÛŒØ±ÙˆØ§Ù„ Ùˆ Ù¾ÙˆØ±Øª 443

**Ù…Ø´Ú©Ù„ 2: Transaction Not Found**
- âœ… Ø¨Ø±Ø±Ø³ÛŒ Authority Ø¯Ø± DB
- âœ… Ø¨Ø±Ø±Ø³ÛŒ timing (callback Ù…Ù…Ú©Ù† Ø§Ø³Øª Ø¯ÛŒØ±ØªØ± Ø¨ÛŒØ§ÛŒØ¯)

**Ù…Ø´Ú©Ù„ 3: Verification Failed**
- âœ… Ø¨Ø±Ø±Ø³ÛŒ Amount (Ø¨Ø§ÛŒØ¯ Ø¯Ù‚ÛŒÙ‚Ø§Ù‹ Ù‡Ù…Ø§Ù† Ù…Ø¨Ù„Øº Ø¨Ø§Ø´Ø¯)
- âœ… Ø¨Ø±Ø±Ø³ÛŒ Merchant ID

---

## 8. Ù†Ú©Ø§Øª Ù…Ù‡Ù… Ùˆ Ø¨Ù‡ØªØ±ÛŒÙ† Ø±ÙˆØ´â€ŒÙ‡Ø§

### 8.1 Ø§Ù…Ù†ÛŒØª

âœ… **Ù‡Ù…ÛŒØ´Ù‡ Ø§Ø² HTTPS Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯**
```go
// âŒ Ø¨Ø¯
callback_url: "http://yourdomain.com/payment/callback"

// âœ… Ø®ÙˆØ¨
callback_url: "https://yourdomain.com/payment/callback"
```

âœ… **Idempotency - Ø¬Ù„ÙˆÚ¯ÛŒØ±ÛŒ Ø§Ø² Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù…Ø¬Ø¯Ø¯**
```go
if transaction.Status == "success" {
    // Ù‚Ø¨Ù„Ø§Ù‹ Ù¾Ø±Ø¯Ø§Ø²Ø´ Ø´Ø¯Ù‡ØŒ Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù†Ú©Ù†
    return
}
```

âœ… **Timeout Ø¨Ø±Ø§ÛŒ HTTP Requests**
```go
client := &http.Client{Timeout: 30 * time.Second}
```

### 8.2 Ù…Ø¯ÛŒØ±ÛŒØª Ø®Ø·Ø§

âœ… **Ù„Ø§Ú¯ Ù‡Ù…Ù‡ Ø®Ø·Ø§Ù‡Ø§**
```go
log.Printf("Payment failed - UserID: %d, Error: %v", userID, err)
```

âœ… **Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§ÛŒ ÙˆØ§Ø¶Ø­ Ø¨Ù‡ Ú©Ø§Ø±Ø¨Ø±**
```go
h.sendErrorMessage(chatID, "âŒ Ø®Ø·Ø§ Ø¯Ø± Ù¾Ø±Ø¯Ø§Ø²Ø´ Ù¾Ø±Ø¯Ø§Ø®Øª. Ù„Ø·ÙØ§Ù‹ Ø¨Ø§ Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ ØªÙ…Ø§Ø³ Ø¨Ú¯ÛŒØ±ÛŒØ¯.")
```

### 8.3 Ø¨Ù‡ÛŒÙ†Ù‡â€ŒØ³Ø§Ø²ÛŒ

âœ… **Ø°Ø®ÛŒØ±Ù‡ Authority Ø¯Ø± DB Ù‚Ø¨Ù„ Ø§Ø² Ø§Ø±Ø³Ø§Ù„ Ø¯Ø±Ø®ÙˆØ§Ø³Øª**
- Ø¯Ø± ØµÙˆØ±Øª Ø®Ø·Ø§ Ø¯Ø± ZarinPalØŒ Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ ØªØ±Ø§Ú©Ù†Ø´ Ø±Ø§ track Ú©Ù†ÛŒØ¯

âœ… **Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Transaction ID Ø¨Ø±Ø§ÛŒ OrderID**
```go
Metadata: {
    OrderID: fmt.Sprintf("%d", transaction.ID),
}
```

### 8.4 Ú†Ú©â€ŒÙ„ÛŒØ³Øª Ù‚Ø¨Ù„ Ø§Ø² Production

- [ ] SSL Ù†ØµØ¨ Ø´Ø¯Ù‡ Ùˆ Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª
- [ ] Callback URL Ø¯Ø± Ù¾Ù†Ù„ ZarinPal ØªÙ†Ø¸ÛŒÙ… Ø´Ø¯Ù‡
- [ ] Sandbox mode = false
- [ ] Merchant ID ØµØ­ÛŒØ­ Ø§Ø³Øª
- [ ] Ù¾ÙˆØ±Øª 443 Ø¨Ø§Ø² Ø§Ø³Øª
- [ ] ØªØ³Øª Ú©Ø§Ù…Ù„ Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯Ù‡
- [ ] Error handling Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ø´Ø¯Ù‡
- [ ] Logging ÙØ¹Ø§Ù„ Ø§Ø³Øª

---

## ğŸ“ Ø®Ù„Ø§ØµÙ‡

### Ù…Ø±Ø§Ø­Ù„ Ø§ØµÙ„ÛŒ:

1. âœ… **Ø³Ø§Ø®ØªØ§Ø± DB**: PaymentTransaction + User fields
2. âœ… **PaymentService**: CreatePaymentRequest + VerifyPayment
3. âœ… **CallbackHandler**: HandleCallback + Notification
4. âœ… **HTTP Routes**: /payment/callback, /payment/success, etc.
5. âœ… **SSL**: Ù†ØµØ¨ Ùˆ ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ HTTPS
6. âœ… **Handlers**: Ø§ØªØµØ§Ù„ Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§ÛŒ Ø±Ø¨Ø§Øª Ø¨Ù‡ PaymentService

### ÙØ§ÛŒÙ„â€ŒÙ‡Ø§ÛŒ Ù…Ù‡Ù…:

- `services/payment.go` - Ù…Ù†Ø·Ù‚ Ù¾Ø±Ø¯Ø§Ø®Øª
- `handlers/payment_callback.go` - Ù…Ø¯ÛŒØ±ÛŒØª callback
- `handlers/handlers.go` - Ù‡Ù†Ø¯Ù„Ø±Ù‡Ø§ÛŒ Ø±Ø¨Ø§Øª
- `main.go` - Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø³Ø±ÙˆØ±
- `config.yaml` - ØªÙ†Ø¸ÛŒÙ…Ø§Øª
- `models/gamification.go` - Ù…Ø¯Ù„ Ø¯ÛŒØªØ§Ø¨ÛŒØ³

---

## ğŸ¯ Ù†ØªÛŒØ¬Ù‡

Ø¨Ø§ Ù¾ÛŒØ±ÙˆÛŒ Ø§Ø² Ø§ÛŒÙ† Ø±Ø§Ù‡Ù†Ù…Ø§ØŒ Ø³ÛŒØ³ØªÙ… Ù¾Ø±Ø¯Ø§Ø®Øª Ú©Ø§Ù…Ù„ Ùˆ Ø§Ù…Ù† Ø¨Ø±Ø§ÛŒ ÙˆØ¨Ø³Ø§ÛŒØª  Ø´Ù…Ø§ Ù¾ÛŒØ§Ø¯Ù‡â€ŒØ³Ø§Ø²ÛŒ Ù…ÛŒâ€ŒØ´ÙˆØ¯. ØªÙ…Ø§Ù… Ú©Ø¯Ù‡Ø§ Ø¢Ù…Ø§Ø¯Ù‡ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù‡Ø³ØªÙ†Ø¯ Ùˆ ÙÙ‚Ø· Ù†ÛŒØ§Ø² Ø¨Ù‡ Ø¬Ø§ÛŒÚ¯Ø²ÛŒÙ†ÛŒ Merchant ID Ùˆ ØªÙ†Ø¸ÛŒÙ… Ø¯Ø§Ù…Ù†Ù‡ Ø¯Ø§Ø±Ù†Ø¯.

**Ø³ÙˆØ§Ù„ ÛŒØ§ Ù…Ø´Ú©Ù„ÛŒ Ø¯Ø§Ø±ÛŒØ¯ØŸ** Ù„Ø§Ú¯â€ŒÙ‡Ø§ Ø±Ø§ Ø¨Ø±Ø±Ø³ÛŒ Ú©Ù†ÛŒØ¯ Ùˆ Ù…Ø·Ù…Ø¦Ù† Ø´ÙˆÛŒØ¯ Ù‡Ù…Ù‡ Ù…Ø±Ø§Ø­Ù„ Ø¨Ù‡ Ø¯Ø±Ø³ØªÛŒ Ø§Ø¬Ø±Ø§ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯.

---

**Ù†ÙˆÛŒØ³Ù†Ø¯Ù‡:** Cursor AI Assistant  
**ØªØ§Ø±ÛŒØ®:** 2025  
**Ù†Ø³Ø®Ù‡:** 1.0

