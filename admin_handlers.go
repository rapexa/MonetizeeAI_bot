package main

import (
	"fmt"
	"strconv"
	"strings"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api"
)

// AdminCommand represents an admin command with its handler
type AdminCommand struct {
	Command     string
	Description string
	Handler     func(admin *Admin, args []string) string
}

var adminCommands = []AdminCommand{
	{
		Command:     "/admin_stats",
		Description: "ğŸ“Š Ù†Ù…Ø§ÛŒØ´ Ø¢Ù…Ø§Ø± Ú©Ù„ÛŒ Ø³ÛŒØ³ØªÙ…",
		Handler:     handleAdminStats,
	},
	{
		Command:     "/admin_users",
		Description: "ğŸ‘¥ Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ø¨Ø±Ø§Ù†",
		Handler:     handleAdminUsers,
	},
	{
		Command:     "/admin_sessions",
		Description: "ğŸ“š Ù…Ø¯ÛŒØ±ÛŒØª Ø¬Ù„Ø³Ø§Øª",
		Handler:     handleAdminSessions,
	},
	{
		Command:     "/admin_videos",
		Description: "ğŸ¥ Ù…Ø¯ÛŒØ±ÛŒØª ÙˆÛŒØ¯ÛŒÙˆÙ‡Ø§",
		Handler:     handleAdminVideos,
	},
	{
		Command:     "/admin_exercises",
		Description: "âœï¸ Ù…Ø¯ÛŒØ±ÛŒØª ØªÙ…Ø±ÛŒÙ†â€ŒÙ‡Ø§",
		Handler:     handleAdminExercises,
	},
	{
		Command:     "/admin_logs",
		Description: "ğŸ“ Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ù„Ø§Ú¯â€ŒÙ‡Ø§ÛŒ Ø³ÛŒØ³ØªÙ…",
		Handler:     handleAdminLogs,
	},
}

// handleAdminCommand processes admin commands
func handleAdminCommand(admin *Admin, command string, args []string) string {
	for _, cmd := range adminCommands {
		if strings.HasPrefix(command, cmd.Command) {
			return cmd.Handler(admin, args)
		}
	}
	return "âŒ Ø¯Ø³ØªÙˆØ± Ù†Ø§Ù…Ø¹ØªØ¨Ø±"
}

// handleAdminStats shows system statistics
func handleAdminStats(admin *Admin, args []string) string {
	var stats struct {
		TotalUsers     int64
		ActiveUsers    int64
		BannedUsers    int64
		TotalSessions  int64
		TotalVideos    int64
		TotalExercises int64
	}

	// Get user statistics
	db.Model(&User{}).Count(&stats.TotalUsers)
	db.Model(&User{}).Where("is_banned = ?", false).Count(&stats.ActiveUsers)
	db.Model(&User{}).Where("is_banned = ?", true).Count(&stats.BannedUsers)

	// Get session statistics
	db.Model(&Session{}).Count(&stats.TotalSessions)

	// Get video statistics
	db.Model(&Video{}).Count(&stats.TotalVideos)

	// Get exercise statistics
	db.Model(&Exercise{}).Count(&stats.TotalExercises)

	response := fmt.Sprintf("ğŸ“Š Ø¢Ù…Ø§Ø± Ø³ÛŒØ³ØªÙ…:\n\n"+
		"ğŸ‘¥ Ú©Ø§Ø±Ø¨Ø±Ø§Ù†:\n"+
		"â€¢ Ú©Ù„ Ú©Ø§Ø±Ø¨Ø±Ø§Ù†: %d\n"+
		"â€¢ Ú©Ø§Ø±Ø¨Ø±Ø§Ù† ÙØ¹Ø§Ù„: %d\n"+
		"â€¢ Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ù…Ø³Ø¯ÙˆØ¯: %d\n\n"+
		"ğŸ“š Ø¬Ù„Ø³Ø§Øª:\n"+
		"â€¢ Ú©Ù„ Ø¬Ù„Ø³Ø§Øª: %d\n\n"+
		"ğŸ¥ ÙˆÛŒØ¯ÛŒÙˆÙ‡Ø§:\n"+
		"â€¢ Ú©Ù„ ÙˆÛŒØ¯ÛŒÙˆÙ‡Ø§: %d\n\n"+
		"âœï¸ ØªÙ…Ø±ÛŒÙ†â€ŒÙ‡Ø§:\n"+
		"â€¢ Ú©Ù„ ØªÙ…Ø±ÛŒÙ†â€ŒÙ‡Ø§: %d",
		stats.TotalUsers,
		stats.ActiveUsers,
		stats.BannedUsers,
		stats.TotalSessions,
		stats.TotalVideos,
		stats.TotalExercises)

	// Add inline keyboard for detailed stats
	keyboard := tgbotapi.NewInlineKeyboardMarkup(
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ“ˆ Ù†Ù…ÙˆØ¯Ø§Ø± Ú©Ø§Ø±Ø¨Ø±Ø§Ù†", "user_chart"),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ“ˆ Ù†Ù…ÙˆØ¯Ø§Ø± Ø¬Ù„Ø³Ø§Øª", "session_chart"),
		),
		tgbotapi.NewInlineKeyboardRow(
			tgbotapi.NewInlineKeyboardButtonData("ğŸ“ˆ Ù†Ù…ÙˆØ¯Ø§Ø± ÙˆÛŒØ¯ÛŒÙˆÙ‡Ø§", "video_chart"),
			tgbotapi.NewInlineKeyboardButtonData("ğŸ“ˆ Ù†Ù…ÙˆØ¯Ø§Ø± ØªÙ…Ø±ÛŒÙ†â€ŒÙ‡Ø§", "exercise_chart"),
		),
	)
	msg := tgbotapi.NewMessage(admin.TelegramID, response)
	msg.ReplyMarkup = keyboard
	bot.Send(msg)

	return "Ø§Ø² Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§ÛŒ Ø²ÛŒØ± Ø¨Ø±Ø§ÛŒ Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ù†Ù…ÙˆØ¯Ø§Ø±Ù‡Ø§ÛŒ Ø¢Ù…Ø§Ø±ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯"
}

// handleAdminUsers manages users
func handleAdminUsers(admin *Admin, args []string) string {
	if len(args) == 0 {
		var users []User
		db.Order("created_at desc").Limit(10).Find(&users)

		response := "ğŸ‘¥ Ø¢Ø®Ø±ÛŒÙ† Ú©Ø§Ø±Ø¨Ø±Ø§Ù†:\n\n"
		for _, user := range users {
			status := "âœ… ÙØ¹Ø§Ù„"
			if user.IsBanned {
				status = "âŒ Ù…Ø³Ø¯ÙˆØ¯"
			}
			response += fmt.Sprintf("ğŸ‘¤ %s\nğŸ“± Ø¢ÛŒØ¯ÛŒ: %d\nğŸ“Š ÙˆØ¶Ø¹ÛŒØª: %s\nâ° ØªØ§Ø±ÛŒØ® Ø¹Ø¶ÙˆÛŒØª: %s\n\n",
				user.Username,
				user.TelegramID,
				status,
				user.CreatedAt.Format("2006-01-02 15:04:05"))
		}

		// Add inline keyboard for actions
		keyboard := tgbotapi.NewInlineKeyboardMarkup(
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("ğŸ” Ø¬Ø³ØªØ¬ÙˆÛŒ Ú©Ø§Ø±Ø¨Ø±", "search_user"),
				tgbotapi.NewInlineKeyboardButtonData("ğŸ“Š Ø¢Ù…Ø§Ø± Ú©Ø§Ø±Ø¨Ø±Ø§Ù†", "user_stats"),
			),
		)
		msg := tgbotapi.NewMessage(admin.TelegramID, response)
		msg.ReplyMarkup = keyboard
		bot.Send(msg)

		return "Ø§Ø² Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§ÛŒ Ø²ÛŒØ± Ø¨Ø±Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª Ú©Ø§Ø±Ø¨Ø±Ø§Ù† Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯"
	}

	// Handle user actions
	switch args[0] {
	case "ban":
		if len(args) < 2 {
			return "âŒ Ù„Ø·ÙØ§ Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±Ø¨Ø± Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯"
		}
		return banUser(admin, args[1])
	case "unban":
		if len(args) < 2 {
			return "âŒ Ù„Ø·ÙØ§ Ø¢ÛŒØ¯ÛŒ Ú©Ø§Ø±Ø¨Ø± Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯"
		}
		return unbanUser(admin, args[1])
	default:
		return "âŒ Ø¯Ø³ØªÙˆØ± Ù†Ø§Ù…Ø¹ØªØ¨Ø±"
	}
}

// handleAdminSessions manages sessions
func handleAdminSessions(admin *Admin, args []string) string {
	if len(args) == 0 {
		var sessions []Session
		db.Order("number desc").Limit(10).Find(&sessions)

		response := "ğŸ“š Ø¢Ø®Ø±ÛŒÙ† Ø¬Ù„Ø³Ø§Øª:\n\n"
		for _, session := range sessions {
			response += fmt.Sprintf("ğŸ“– Ø¬Ù„Ø³Ù‡ %d: %s\nğŸ“ %s\n\n",
				session.Number,
				session.Title,
				session.Description)
		}

		// Add inline keyboard for actions
		keyboard := tgbotapi.NewInlineKeyboardMarkup(
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("â• Ø§ÙØ²ÙˆØ¯Ù† Ø¬Ù„Ø³Ù‡", "add_session"),
				tgbotapi.NewInlineKeyboardButtonData("âœï¸ ÙˆÛŒØ±Ø§ÛŒØ´ Ø¬Ù„Ø³Ù‡", "edit_session"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("ğŸ—‘ï¸ Ø­Ø°Ù Ø¬Ù„Ø³Ù‡", "delete_session"),
				tgbotapi.NewInlineKeyboardButtonData("ğŸ“Š Ø¢Ù…Ø§Ø± Ø¬Ù„Ø³Ø§Øª", "session_stats"),
			),
		)
		msg := tgbotapi.NewMessage(admin.TelegramID, response)
		msg.ReplyMarkup = keyboard
		bot.Send(msg)

		return "Ø§Ø² Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§ÛŒ Ø²ÛŒØ± Ø¨Ø±Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª Ø¬Ù„Ø³Ø§Øª Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯"
	}

	// Handle session actions
	switch args[0] {
	case "edit":
		if len(args) < 4 {
			return "âŒ Ù„Ø·ÙØ§ Ø´Ù…Ø§Ø±Ù‡ Ø¬Ù„Ø³Ù‡ØŒ Ø¹Ù†ÙˆØ§Ù† Ùˆ ØªÙˆØ¶ÛŒØ­Ø§Øª Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯"
		}
		return editSession(admin, args[1], args[2], args[3])
	case "delete":
		if len(args) < 2 {
			return "âŒ Ù„Ø·ÙØ§ Ø´Ù…Ø§Ø±Ù‡ Ø¬Ù„Ø³Ù‡ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯"
		}
		return deleteSession(admin, args[1])
	default:
		return "âŒ Ø¯Ø³ØªÙˆØ± Ù†Ø§Ù…Ø¹ØªØ¨Ø±"
	}
}

// handleAdminVideos manages videos
func handleAdminVideos(admin *Admin, args []string) string {
	if len(args) == 0 {
		var videos []Video
		db.Order("created_at desc").Limit(10).Find(&videos)

		response := "ğŸ¥ Ø¢Ø®Ø±ÛŒÙ† ÙˆÛŒØ¯ÛŒÙˆÙ‡Ø§:\n\n"
		for _, video := range videos {
			response += fmt.Sprintf("ğŸ“º %s\nğŸ”— %s\n\n",
				video.Title,
				video.URL)
		}

		// Add inline keyboard for actions
		keyboard := tgbotapi.NewInlineKeyboardMarkup(
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("â• Ø§ÙØ²ÙˆØ¯Ù† ÙˆÛŒØ¯ÛŒÙˆ", "add_video"),
				tgbotapi.NewInlineKeyboardButtonData("âœï¸ ÙˆÛŒØ±Ø§ÛŒØ´ ÙˆÛŒØ¯ÛŒÙˆ", "edit_video"),
			),
			tgbotapi.NewInlineKeyboardRow(
				tgbotapi.NewInlineKeyboardButtonData("ğŸ—‘ï¸ Ø­Ø°Ù ÙˆÛŒØ¯ÛŒÙˆ", "delete_video"),
				tgbotapi.NewInlineKeyboardButtonData("ğŸ“Š Ø¢Ù…Ø§Ø± ÙˆÛŒØ¯ÛŒÙˆÙ‡Ø§", "video_stats"),
			),
		)
		msg := tgbotapi.NewMessage(admin.TelegramID, response)
		msg.ReplyMarkup = keyboard
		bot.Send(msg)

		return "Ø§Ø² Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§ÛŒ Ø²ÛŒØ± Ø¨Ø±Ø§ÛŒ Ù…Ø¯ÛŒØ±ÛŒØª ÙˆÛŒØ¯ÛŒÙˆÙ‡Ø§ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯"
	}

	// Handle video actions
	switch args[0] {
	case "add":
		if len(args) < 4 {
			return "âŒ Ù„Ø·ÙØ§ Ø´Ù…Ø§Ø±Ù‡ Ø¬Ù„Ø³Ù‡ØŒ Ø¹Ù†ÙˆØ§Ù† Ùˆ Ù„ÛŒÙ†Ú© ÙˆÛŒØ¯ÛŒÙˆ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯"
		}
		return addVideo(admin, args[1], args[2], args[3])
	case "edit":
		if len(args) < 4 {
			return "âŒ Ù„Ø·ÙØ§ Ø¢ÛŒØ¯ÛŒ ÙˆÛŒØ¯ÛŒÙˆØŒ Ø¹Ù†ÙˆØ§Ù† Ùˆ Ù„ÛŒÙ†Ú© Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯"
		}
		return editVideo(admin, args[1], args[2], args[3])
	default:
		return "âŒ Ø¯Ø³ØªÙˆØ± Ù†Ø§Ù…Ø¹ØªØ¨Ø±"
	}
}

// handleAdminExercises manages exercises
func handleAdminExercises(admin *Admin, args []string) string {
	if len(args) == 0 {
		// Show pending exercises
		var exercises []Exercise
		db.Preload("User").Preload("Session").Where("status = ?", "pending").Order("created_at desc").Limit(10).Find(&exercises)

		response := "âœï¸ ØªÙ…Ø±ÛŒÙ†â€ŒÙ‡Ø§ÛŒ Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø± Ø¨Ø±Ø±Ø³ÛŒ:\n\n"
		for _, exercise := range exercises {
			response += fmt.Sprintf("ID: %d\nÚ©Ø§Ø±Ø¨Ø±: %s\nØ¬Ù„Ø³Ù‡: %d\nÙ…Ø­ØªÙˆØ§: %s\n\n",
				exercise.ID, exercise.User.Username, exercise.Session.Number, exercise.Content)
		}
		response += "\nØ¯Ø³ØªÙˆØ±Ø§Øª:\nâ€¢ approve [Ø¢ÛŒØ¯ÛŒ] [Ù†Ø¸Ø±Ø§Øª] - ØªØ§ÛŒÛŒØ¯ ØªÙ…Ø±ÛŒÙ†\nâ€¢ reject [Ø¢ÛŒØ¯ÛŒ] [Ù†Ø¸Ø±Ø§Øª] - Ø±Ø¯ ØªÙ…Ø±ÛŒÙ†"
		return response
	}

	// Handle exercise management commands
	switch args[0] {
	case "approve":
		if len(args) < 3 {
			return "âŒ ÙØ±Ù…Øª Ø¯Ø³ØªÙˆØ±: /admin_exercises approve [Ø¢ÛŒØ¯ÛŒ] [Ù†Ø¸Ø±Ø§Øª]"
		}
		exerciseID, err := strconv.ParseUint(args[1], 10, 32)
		if err != nil {
			return "âŒ Ø¢ÛŒØ¯ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø±"
		}
		var exercise Exercise
		if err := db.First(&exercise, exerciseID).Error; err != nil {
			return "âŒ ØªÙ…Ø±ÛŒÙ† ÛŒØ§ÙØª Ù†Ø´Ø¯"
		}
		exercise.Status = "approved"
		exercise.Feedback = strings.Join(args[2:], " ")
		db.Save(&exercise)
		logAdminAction(admin, "approve_exercise", fmt.Sprintf("Approved exercise %d", exerciseID), "exercise", uint(exerciseID))
		return "âœ… ØªÙ…Ø±ÛŒÙ† Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª ØªØ§ÛŒÛŒØ¯ Ø´Ø¯"

	case "reject":
		if len(args) < 3 {
			return "âŒ ÙØ±Ù…Øª Ø¯Ø³ØªÙˆØ±: /admin_exercises reject [Ø¢ÛŒØ¯ÛŒ] [Ù†Ø¸Ø±Ø§Øª]"
		}
		exerciseID, err := strconv.ParseUint(args[1], 10, 32)
		if err != nil {
			return "âŒ Ø¢ÛŒØ¯ÛŒ Ù†Ø§Ù…Ø¹ØªØ¨Ø±"
		}
		var exercise Exercise
		if err := db.First(&exercise, exerciseID).Error; err != nil {
			return "âŒ ØªÙ…Ø±ÛŒÙ† ÛŒØ§ÙØª Ù†Ø´Ø¯"
		}
		exercise.Status = "needs_revision"
		exercise.Feedback = strings.Join(args[2:], " ")
		db.Save(&exercise)
		logAdminAction(admin, "reject_exercise", fmt.Sprintf("Rejected exercise %d", exerciseID), "exercise", uint(exerciseID))
		return "âœ… ØªÙ…Ø±ÛŒÙ† Ø¨Ø§ Ù…ÙˆÙÙ‚ÛŒØª Ø±Ø¯ Ø´Ø¯"

	default:
		return "âŒ Ø¯Ø³ØªÙˆØ± Ù†Ø§Ù…Ø¹ØªØ¨Ø±"
	}
}

// handleAdminLogs shows system logs
func handleAdminLogs(admin *Admin, args []string) string {
	var actions []AdminAction
	db.Preload("Admin").Order("created_at desc").Limit(10).Find(&actions)

	response := "ğŸ“ Ø¢Ø®Ø±ÛŒÙ† ÙØ¹Ø§Ù„ÛŒØªâ€ŒÙ‡Ø§ÛŒ Ø§Ø¯Ù…ÛŒÙ†:\n\n"
	for _, action := range actions {
		response += fmt.Sprintf("Ø§Ø¯Ù…ÛŒÙ†: %s\nØ¹Ù…Ù„ÛŒØ§Øª: %s\nØ¬Ø²Ø¦ÛŒØ§Øª: %s\nØªØ§Ø±ÛŒØ®: %s\n\n",
			action.Admin.Username, action.Action, action.Details, action.CreatedAt.Format("2006-01-02 15:04:05"))
	}
	return response
}

// logAdminAction logs admin activities
func logAdminAction(admin *Admin, action string, details string, targetType string, targetID uint) {
	adminAction := AdminAction{
		AdminID:    admin.ID,
		Action:     action,
		Details:    details,
		TargetType: targetType,
		TargetID:   targetID,
	}
	db.Create(&adminAction)
}

// isAdmin checks if a user is an admin
func isAdmin(telegramID int64) bool {
	var admin Admin
	result := db.Where("telegram_id = ? AND is_active = ?", telegramID, true).First(&admin)
	return result.Error == nil
}

// getAdmin returns admin by telegram ID
func getAdmin(telegramID int64) *Admin {
	var admin Admin
	if err := db.Where("telegram_id = ?", telegramID).First(&admin).Error; err != nil {
		return nil
	}
	return &admin
}
